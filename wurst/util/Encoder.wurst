package Encoder
import BigString
import BigNum
import SeqWorker
// Encodes numbers into ones with higher bases and represents them in the shortest possible way
// Credits: Pipedream
public constant maxInt = 2147483647
public constant maxHash = 1000

public class Encoder
	string charset
	int base
	real digits	= 0.	//logarithmic approximation
	BigNum bignum 

	construct(string charset)
		this.charset = charset
		this.base = charset.length()
		this.bignum = new BigNum(base)
	
	ondestroy
		destroy bignum

	function encode(int val, int max)
		printLog(Loglevel.DEBUG, "encode val: " + val.toString() + " max: " + max.toString())
		digits = digits + log(max+1.,base+0.)
		printLog(Loglevel.DEBUG, "encode2")
		bignum.mulSmall(max+1)
		printLog(Loglevel.DEBUG, "encode3")
		bignum.addSmall(val)
		printLog(Loglevel.DEBUG, "encode4")
	
	function decode(int max) returns int
		return bignum.divSmall(max+1)
	
	function isEmpty() returns boolean
		return bignum.isZero()
	
	function length() returns real
		return digits
	
	function clean()
		bignum.clean()
	
	function pad()
		BigNum_l cur = bignum.list
		BigNum_l prev = null
		int maxlen = R2I(1.0 + length())
		
		while cur != null
			prev = cur
			cur = cur.next
			maxlen--
			
		while maxlen > 0
			prev.next = new BigNum_l()
			prev = prev.next
			maxlen--
	
	
	function toString(BigString big, PayloadCallback onFinish) 
		BigNum_l cur = bignum.list
		doSeq((SeqCallback cb) -> begin
			var continue = true
			if cur != null
				big.addString(itochar(cur.leaf))
				cur = cur.next
			else
				continue = false
				onFinish.customData = big castTo int
				onFinish.doStep()
			return continue
		end)
	
	function fromString(BigString bs, PayloadCallback onFinishString)
		int i = 0
		BigNum_l cur = new BigNum_l()
		bignum.list = cur
		printLog(Loglevel.DEBUG, "from String")
		doSeq((SeqCallback cb) -> begin
			var continue = true
			cur.leaf = chartoi(bs.getString(i, 1))
			if i < bs.getLength()-1
				cur.next = new BigNum_l()
				cur = cur.next
				i++
			else
				continue = false
				destroy bs
				onFinishString.doStep()
			return continue
		end)
	
	function hash() returns int
		printLog(Loglevel.DEBUG, "hash")
		int hash = 0
		int x
		BigNum_l cur = bignum.list
		while cur != null
			x = cur.leaf
			hash = ModuloInteger(hash+79*hash div (x+1) + 293*x div (1+hash - (hash div base)*base) + 479,maxHash)
			cur = cur.next
		printLog(Loglevel.DEBUG, "hashed")
		return hash

	function save(BigString bs, PayloadCallback onFinish)
		printLog(Loglevel.DEBUG, "save1")
		clean()
		printLog(Loglevel.DEBUG, "save2")
		let hash = hash()
		nullTimer(() -> begin
			printLog(Loglevel.DEBUG, "test")
		end)
		nullTimer(() -> begin
			printLog(Loglevel.DEBUG, "hash: " + hash.toString())
			encode(hash,maxHash)
			printLog(Loglevel.DEBUG, "encoded hash")
			clean()
			printLog(Loglevel.DEBUG, "clean")
			pad()
			printLog(Loglevel.DEBUG, "before toString")
			toString(bs, onFinish)
		end)
		nullTimer(() -> begin
			printLog(Loglevel.DEBUG, "test2")
		end)
		

	function load(BigString bs, PayloadCallback onFinishLoad)
		fromString(bs, (PayloadCallback cb) -> begin
			printLog(Loglevel.DEBUG, "loaded..")
			let inputhash = decode(maxHash)
			printLog(Loglevel.DEBUG, "decoded..")
			clean()
			printLog(Loglevel.DEBUG, "claned..")
			let h = hash()
			printLog(Loglevel.DEBUG, "hashed..")
			onFinishLoad.customData = (inputhash == h).toInt()
			onFinishLoad.doStep()
		end)
		

	function chartoi( string c ) returns int
		int i = 0
		string cs = charset
		int len = base
		while i < len and c != SubString(cs,i,i+1)
			i = i + 1
		return i

	function itochar( int i ) returns string
		return SubString(charset,i,i+1)
	

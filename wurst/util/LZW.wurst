package LZW
import LinkedList
import ClosureTimers
import public BigString
import public SeqWorker
import TypeCasting
import ErrorHandling
import Encoder

/** Lempel Ziv Welch Compression */

constant maxDictSize = 4000
constant string DICT_INIT                   = "_0123456789abcdefghijklmnopqrstuvwxyz-[]"
constant string ALLOWED_PLAYER_CHARS 		= "0aUb1GLwR2kHvP3CQIM4npFs5iSW6tzAr7TNxo8JXVjy9OcdEfBKgqeuYDhmlZ[]."

function encodePositions(LinkedList<int> intList, int dictSize, PayloadCallback onFinish)
	if dictSize > maxDictSize
		error("dictionary size exceeds max size")

	var st = ""
	for s in intList
		st+= s.toString() + ","
	print("encoding positions: " + st)
	let encoder = new Encoder(ALLOWED_PLAYER_CHARS)
	// let max = intList.getSize()
	let itr = intList.staticItr()
	doSeq(10, (SeqCallback cb) -> begin
		if itr.hasNext()
			encoder.encode(itr.next(), dictSize)
		else
			cb.terminate()
			encoder.encode(dictSize, maxDictSize)
			onFinish.customData = encoder.save(new BigString()) castTo int
			destroy encoder
			onFinish.doStep()
	end)
		
	

function decodePositions(BigString input, PayloadCallback onFinish)
	let encoder = new Encoder(ALLOWED_PLAYER_CHARS)
	encoder.load(input, (PayloadCallback cb) -> begin
		if cb.customData == 1
			print("File is valid")
			let dictSize = encoder.decode(maxDictSize)
			let positions = new LinkedList<int>
			doSeq(5, (SeqCallback cb) -> begin
				if not encoder.bignum.isZero()
					let dec = encoder.decode(dictSize)
					positions.addtoStart(dec)
				else
					cb.terminate()
					var st = ""
					for s in positions
						st+= s.toString() + ","
					print("decoded positions: " + st)
					onFinish.customData = positions castTo int
					onFinish.doStep()
			end)
			
			
		else
			error("loaded input is invalid")
	end)
		

/**
	* @return boolean - True if compression is successful,
	* false otherwise.
	*/
public function compress(BigString data, PayloadCallback onFinish) 
	print("compress:")
	data.debugPrint()
	LinkedList<int> intList = new LinkedList<int>()
	LinkedList<string> dictionary = new LinkedList<string>()
	for c in DICT_INIT
		dictionary.add(c)
		
	int inc = 0
	BigSubString A = null
	BigSubString B = null
	doSeq(5, (SeqCallback cb) -> begin
		if (inc < data.getLength() - 1)
			A = data.charAt(inc)  
			inc++
			B = data.charAt(inc)     //Z is next character
			A.concat(B)
			while true     //Loop until the sequence of
				if not dictionary.contains(A.getCombined())
					break
				A = new BigSubString(A.getSingle() + B.getSingle())
				inc++
				if (inc < data.getLength())
					B = data.charAt(inc)
					A.concat(B)
				else
					break
			
			//Write index to output
			intList.add(dictionary.indexOf(A.getSingle()))

			dictionary.add(A.getCombined())

		//        output += (dictionary.indexOf(Z) + " ");
		else
			if B != null and A.getSingle().charAt(A.getSingleLength()-1) != B.getSingle()
				intList.add(dictionary.indexOf(B.getSingle()))
			cb.terminate()
			var st = ""
			for s in dictionary
				st+= s + ","
			print("dict: " + st)
			encodePositions(intList, dictionary.getSize(), (PayloadCallback cb2) -> begin
				let encoded = cb2.customData castTo BigString
				print("inputlength: " + data.getLength().toString() + " outputlength: " + encoded.getLength().toString())
				encoded.debugPrint()
				onFinish.customData = encoded castTo int
				onFinish.doStep()
			end)
			
	end)

/**
	* @return boolean - true if successful, false otherwise.
	*/
public function decompress(BigString input, PayloadCallback onFinish)
	print("Decompress")
	let output = new BigString()
	LinkedList<string> dictionary = new LinkedList<string>()
	for c in DICT_INIT
		dictionary.add(c)
	
	decodePositions(input, (PayloadCallback cb1) -> begin
		let positions = cb1.customData castTo LinkedList<int>
		let itr = positions.staticItr()
		string A = ""
		string B = ""
		
		doSeq(5, (SeqCallback cb2) -> begin
			if itr.hasNext()
				let idx = itr.next()
				A = dictionary.get(idx)
				if (itr.hasNext() and itr.lookahead() < dictionary.getSize())
					B = dictionary.get(itr.lookahead())
					B = B.charAt(0)       //Add first letter of next String
				else if (not itr.hasNext())       //Reached end of input
					B = null
				else                                //Dictionary does not have next index
					B = A.charAt(0)        //must be first letter of current String
				if (B != null)
					dictionary.add(A + B)

				output.addString(A)
			else
				cb2.terminate()
				print("decompressed: ")
				output.debugPrint()
				onFinish.customData = output castTo int
				onFinish.doStep()
		end)
	end)
	
	
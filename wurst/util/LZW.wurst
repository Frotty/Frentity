package LZW
import LinkedList
import ClosureTimers
import public BigString
import public SeqWorker
import TypeCasting
import ErrorHandling
import Encoder

/** Lempel Ziv Welch Compression */

constant maxDictSize = 4000
constant string DICT_INIT                   = "_0123456789abcdefghijklmnopqrstuvwxyz-[]"
constant string ALLOWED_PLAYER_CHARS 		= "0aUb1GLwR2kHvP3CQIM4npFs5iSW6tzAr7TNxo8JXVjy9OcdEfBKgqeuYDhmlZ"

function encodePositions(LinkedList<int> intList, int dictSize, PayloadCallback onFinish)
	if dictSize > maxDictSize
		error("dictionary size exceeds max size")

	if DEBUG_LEVEL == Loglevel.TRACE
		var st = ""
		for s in intList
			st+= s.toString() + ","
		printLog(Loglevel.TRACE, "encoding positions: " + st)
	let encoder = new Encoder(ALLOWED_PLAYER_CHARS)
	// let max = intList.getSize()
	let itr = intList.staticItr()
	doSeq(2, (SeqCallback cb) -> begin
		if itr.hasNext()
			print("encode step")
			encoder.encode(itr.next(), dictSize)
		else
			print("encode done")
			cb.terminate()
			encoder.encode(dictSize, maxDictSize)
			encoder.save(new BigString(), (PayloadCallback pc) -> begin
				onFinish.customData = pc.customData
				destroy encoder
				onFinish.doStep()
			end) 
			
	end)
		
	

function decodePositions(BigString input, PayloadCallback onFinish)
	let encoder = new Encoder(ALLOWED_PLAYER_CHARS)
	print("load from")
	input.debugPrint()
	encoder.load(input, (PayloadCallback cb) -> begin
		if cb.customData == 1
			let dictSize = encoder.decode(maxDictSize)
			print("File is valid dictsize : " + dictSize.toString())
			let positions = new LinkedList<int>
			doSeq(2, (SeqCallback cb) -> begin
				if not encoder.bignum.isZero()
					let dec = encoder.decode(dictSize)
					positions.addtoStart(dec)
				else
					cb.terminate()
					if DEBUG_LEVEL == Loglevel.TRACE
						var st = ""
						for s in positions
							st+= s.toString() + ","
						printLog(Loglevel.TRACE,"decoded positions: " + st)
					onFinish.customData = positions castTo int
					onFinish.doStep()
			end)
		else
			error("loaded input is invalid")
	end)
		

/**
	* @return boolean - True if compression is successful,
	* false otherwise.
	*/
public function compress(BigString data, PayloadCallback onFinish) 
	print("compress:")
	data.debugPrint()
	LinkedList<int> intList = new LinkedList<int>()
	LinkedList<string> dictionary = new LinkedList<string>()
	for c in DICT_INIT
		dictionary.add(c)
		
	int inc = 0
	BigSubString A = null
	BigSubString B = null
	doSeq(3, (SeqCallback cb) -> begin
		if (inc < data.getLength() - 1)
			if A != null
				destroy A
			A = data.charAt(inc)  
			inc++
			if B != null
				destroy B
			B = data.charAt(inc)     //Z is next character
			A.concat(B)
			while true     //Loop until the sequence of
				if not dictionary.contains(A.getCombined())
					break
				if A != null
					destroy A
				A = new BigSubString(A.getSingle() + B.getSingle())
				inc++
				if (inc < data.getLength())
					if B != null
						destroy B
					B = data.charAt(inc)
					A.concat(B)
				else
					break
			
			//Write index to output
			intList.add(dictionary.indexOf(A.getSingle()))

			dictionary.add(A.getCombined())

		//        output += (dictionary.indexOf(Z) + " ");
		else
			if B != null and A.getSingle().charAt(A.getSingleLength()-1) != B.getSingle()
				intList.add(dictionary.indexOf(B.getSingle()))
			cb.terminate()
			if DEBUG_LEVEL == Loglevel.TRACE
				var st = ""
				for s in dictionary
					st+= s + ","
				print("dict: " + st)
			print("encode start")
			encodePositions(intList, dictionary.getSize(), (PayloadCallback cb2) -> begin
				print("callback")
				let encoded = cb2.customData castTo BigString
				print("inputlength: " + data.getLength().toString() + " outputlength: " + encoded.getLength().toString())
				encoded.debugPrint()
				onFinish.customData = encoded castTo int
				onFinish.doStep()
				nullTimer(() -> destroy dictionary)
			end)
			
	end)

/**
	* @return boolean - true if successful, false otherwise.
	*/
public function decompress(BigString input, PayloadCallback onFinish)
	print("Decompress")
	let output = new BigString()
	LinkedList<string> dictionary = new LinkedList<string>()
	for c in DICT_INIT
		dictionary.add(c)
	
	decodePositions(input, (PayloadCallback cb1) -> begin
		let positions = cb1.customData castTo LinkedList<int> 
		let itr = positions.staticItr()
		string A = ""
		string B = ""
		
		doSeq(5, (SeqCallback cb2) -> begin
			if itr.hasNext()
				let idx = itr.next()
				A = dictionary.get(idx)
				if (itr.hasNext() and itr.lookahead() < dictionary.getSize())
					B = dictionary.get(itr.lookahead())
					B = B.charAt(0)       //Add first letter of next String
				else if (not itr.hasNext())       //Reached end of input
					B = null
				else                                //Dictionary does not have next index
					B = A.charAt(0)        //must be first letter of current String
				if (B != null and B.length() > 0)
					dictionary.add(A + B)

				output.addString(A)
			else
				cb2.terminate()
				destroy dictionary
				print("decompressed: ")
				output.debugPrint()
				onFinish.customData = output castTo int
				onFinish.doStep()
		end)
	end)
	
	
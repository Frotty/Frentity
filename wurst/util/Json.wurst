package Json
import HashMap
import LinkedList
import public Scanner
import ErrorHandling
import public BigString
import TypeCasting
import LZW
import SeqWorker
import initlater JsonParser

public constant JSON_SIGN_EQUAL = new Delimiter("=")
public constant JSON_SIGN_COMMA = new Delimiter("_")
public constant JSON_OPEN_BRACKET = new Delimiter("(")
public constant JSON_CLOSE_BRACKET = new Delimiter(")")
public constant JSON_OPEN_ARRAY = new Delimiter("[")
public constant JSON_CLOSE_ARRAY = new Delimiter("]")
public constant JSON_HEADER = new Delimiter("J")

public class Property
	BigSubString name
	BigSubString value

	construct(BigSubString name, BigSubString value)
		this.name = name
		this.value = value
		name.concat(value)

	construct(string name, string value)
		this.name = new BigSubString(name)
		this.value = new BigSubString(value)
		this.name.concat(this.value)

	function toSubString() returns BigSubString
		return name

public class Json
	HashMap<int, Property> properties = new HashMap<int, Property>()
	LinkedList<Property> plist = new LinkedList<Property>()

	function addProperty(Property p)
		plist.add(p)
		properties.put(p.name.getSingle().getHash(), p)
		// print("add prop: " + p.name.getCombined() + " start: " + p.name.getStart().toString())

	function getProperty(string key) returns Property
		return properties.get(key.getHash())

	function getReal(string key) returns real
		return getInt(key).toReal()

	function getInt(string key) returns int
		let s = getString(key)
		if s == null or s.getSingleLength() == 0
			return 0
		let ss = s.getSingle()
		return ss.toInt()

	function getString(string key) returns BigSubString
		return properties.get(key.getHash()).value

	function getStringList(string key, JsonParser parser, SeqCallback finalCallback)
		let str = getString(key)
		finalCallback.customData = parser castTo int
		parser.setInput(new BigString()..addSubString(str))
		parser.parseList(finalCallback)
	

	function addToBigString(BigString big) returns BigString
		for p from plist.staticItr()
			let ps = p.toSubString()
			if ps.getSingleLength() > 0
				big.addSubString(ps)
		return big

	function reset()
		properties.flush()
		let itr = plist.staticItr()
		for p from itr
			destroy itr.remove()
				
	ondestroy
		destroy properties
		for p from plist.staticItr()
			destroy p
		destroy plist


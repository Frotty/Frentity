package Event
import public EventHelper
import RegisterEvents
import ClosureTimers
import AbilityObjEditing
import ObjectIdGenerator
import UnitIndexer
import initlater DebugInfo

public constant EVENT_PLAYER_CHAT_FILTER = ConvertPlayerEvent(96)
public constant DONT_FIRE_EVENTS_ID = compiletime(ABIL_ID_GEN.next())

/**
	This package is a comfort wrapper around wc3 events,
	for easy global and per-unit event listening via closures.

	To listen to an event, simply call:

		> EventListener.add(someUnit, EVENT_PLAYER_UNIT_SPELL_EFFECT) ->
		>	 <spell actions>

	**IMPORTANT**:
		Make sure to always use the "EVENT_PLAYER_UNIT_*" variants of the eventids.
		Other supported events:
			- EVENT_PLAYER_LEAVE
			- EVENT_UNIT_DAMAGED
			- EVENT_PLAYER_CHAT_FILTER
			- EVENT_PLAYER_ARROW_*
*/
public abstract class EventListener
	static EventListener array generalListenersFirsts
	static EventListener array unitListenersFirsts

	int eventId = 0
	EventListener next = null
	EventListener prev = null

	abstract function onEvent()
	
	static function add(eventid eventId, EventListener listener) returns EventListener
		listener.eventId = eventId.toIntId()
		if generalListenersFirsts[listener.eventId] != null
			generalListenersFirsts[listener.eventId].prev = listener
			listener.next = generalListenersFirsts[listener.eventId]

		generalListenersFirsts[listener.eventId] = listener
		return listener
		
	static function add(unit u, eventid eventId, EventListener listener) returns EventListener
		let uid = u.getIndex()
		if uid <= 0
			return listener
		listener.eventId = eventId.toIntId()
		// print("adding eventlistener to entityid: " + uid.toString() + " eventid: " + listener.eventId.toString())
		if unitListenersFirsts[uid] != null
			unitListenersFirsts[uid].prev = listener
			listener.next = unitListenersFirsts[uid]
		unitListenersFirsts[uid] = listener
		return listener
			
	static function generalEventCallback()
		let trigUnit = GetTriggerUnit()
		let id = GetTriggerEventId().toIntId()
		eventCallbacksPerSecond++
		// Unit Listeners
		if trigUnit != null and not trigUnit.hasAbility(DONT_FIRE_EVENTS_ID) and trigUnit.getIndex() > 0
			if unitListenersFirsts[trigUnit.getIndex()] != null 
				var listener = unitListenersFirsts[trigUnit.getIndex()]
				while listener != null
					if listener.eventId == id
						listener.onEvent()
					listener = listener.next
		// Global Listeners		
		if generalListenersFirsts[id] != null
			var listener = generalListenersFirsts[id]
			while listener != null
				listener.onEvent()
				listener = listener.next
		
	ondestroy
		var listener = generalListenersFirsts[this.eventId]
		if listener == this
			generalListenersFirsts[this.eventId] = next
		else if prev != null
			prev.next = next
			
		next.prev = prev

		listener = unitListenersFirsts[this.eventId]
		if listener == this
			unitListenersFirsts[this.eventId] = next
		else if prev != null
			prev.next = next
			
		next.prev = prev

		next = null
		prev = null
	
let unitTrig = CreateTrigger()
let leaveTrig = CreateTrigger()
let keyTrig = CreateTrigger()

public function eventid.toIntId() returns int
	var id = eventidToIndex[this.getHandleId()]
	if id == 0
		id = registerEventId(this)
	return id
			
int array eventidToIndex
var eventTypeCounter = 0

function registerEventId(eventid evnt) returns int
	let eventId = evnt.getHandleId()
	eventTypeCounter++
	eventidToIndex[eventId] = eventTypeCounter
	if evnt.isPlayerunitEvent()
		Log.debug("reg handleid: " + eventId.toString() + " -> eventId: " + eventTypeCounter.toString())
		registerPlayerUnitEvent(ConvertPlayerUnitEvent(eventId), function EventListener.generalEventCallback)
	else if evnt != EVENT_UNIT_DAMAGED and evnt != EVENT_PLAYER_LEAVE and evnt != EVENT_PLAYER_CHAT_FILTER and not evnt.isKeyboardEvent()
		printLog(Loglevel.ERROR, "registering handleid: " + eventId.toString() + " non-playerunitevent. Except EVENT_UNIT_DAMAGED and EVENT_PLAYER_LEAVE these are not supported right now.")
	return eventTypeCounter
	
function registerEventsForUnit(unit u)
	if not u.hasAbility(DONT_FIRE_EVENTS_ID)
		unitTrig.registerUnitEvent(u, EVENT_UNIT_DAMAGED)

public function unregisterEventsForUnit(unit u)
	if not u.hasAbility(DONT_FIRE_EVENTS_ID)
		unregisterEvents(u.getIndex())

public function unregisterEvents(int id)
	if id > 0 and EventListener.unitListenersFirsts[id] != null
		printLog(Loglevel.TRACE, "unregister unit has listeners. startid: " + id.toString())
		var listener = EventListener.unitListenersFirsts[id]
		EventListener.unitListenersFirsts[id] = null
		while listener != null
			let t = listener
			listener = listener.next
			destroy t

init
	nullTimer() ->
		// Register Events when unit enters map
		onUnitIndex(() -> registerEventsForUnit(getIndexedUnit()))
		// Delete 
		onUnitDeindex(() -> unregisterEventsForUnit(getDeindexedUnit()))
		
		// Register Actions
		unitTrig.addAction(() -> EventListener.generalEventCallback())	
		leaveTrig.addAction(() -> EventListener.generalEventCallback())
		keyTrig.addAction(() -> EventListener.generalEventCallback())

		for i = 0 to bj_MAX_PLAYERS-1
			leaveTrig.registerPlayerEvent(players[i], EVENT_PLAYER_LEAVE)
			keyTrig..registerPlayerEvent(players[i], EVENT_PLAYER_ARROW_DOWN_DOWN)
			..registerPlayerEvent(players[i], EVENT_PLAYER_ARROW_DOWN_UP)
			..registerPlayerEvent(players[i], EVENT_PLAYER_ARROW_UP_DOWN)
			..registerPlayerEvent(players[i], EVENT_PLAYER_ARROW_UP_UP)
			..registerPlayerEvent(players[i], EVENT_PLAYER_ARROW_LEFT_DOWN)
			..registerPlayerEvent(players[i], EVENT_PLAYER_ARROW_LEFT_UP)
			..registerPlayerEvent(players[i], EVENT_PLAYER_ARROW_RIGHT_DOWN)
			..registerPlayerEvent(players[i], EVENT_PLAYER_ARROW_RIGHT_UP)
			..registerPlayerEvent(players[i], EVENT_PLAYER_END_CINEMATIC)
			..registerPlayerChatEvent(players[i], "", false)


@compiletime function genObj()
	new AbilityDefinitionDefenseBonusPlus1(DONT_FIRE_EVENTS_ID)
	..setDefenseBonus(1, 0)
	..setName("Dummy Event Ability")
package Collision
import Entity

constant globalWorld = new CollisionWorld(playableMapRect)

public tuple rectangle(vec2 min, vec2 max)

public function rectangle.intersect(rectangle other) returns boolean
	return not (other.min.x > this.max.x or other.max.x < this.min.x or other.max.y > this.min.y or other.min.y < this.max.y)

public function rectangle.contains(vec2 point) returns boolean 
	return point.x > this.min.x and point.x < this.max.x and point.y > this.min.y and point.y < this.max.y


public interface CollisionShape
	abstract function intersect(Entity e1, Entity e2) returns boolean

public abstract class CollisionListener
	abstract function onHit(Entity e1, Entity e2)

public class SphereShape implements CollisionShape

	override function intersect(Entity e1, Entity e2) returns boolean
		return e1.getPos().distanceToSq(e2.getPos()) <= e1.radius2 + e2.radius2

public constant SHAPE_SPHERE = new SphereShape()

public function registerCollider(Entity e, CollisionShape shape, CollisionListener listener)
	shapes[e castTo int] = shape
	listeners[e castTo int] = listener
	globalWorld.colliders.add()

public function registerCollidable(Entity e, CollisionShape shape, CollisionListener listener)
	shapes[e castTo int] = shape
	listeners[e castTo int] = listener
	globalWorld.collidables.add(e)

CollisionShape array shapes
CollisionListener array listeners
public class CollisionWorld
	rectangle worldBounds
	let colliders = new LinkedList<Entity>()
	let collidables = new LinkedList<Entity>()

	construct(rect re)
		worldBounds = rectangle(vec2(re.getMinX(), re.getMinY()), vec2(re.getMaxX(), re.getMaxY()))

	function update(real _delta)
		colliders.get(0)
		// iterate through list of collision objects
		for collider from colliders.staticItr()
			for collidable from collidables.staticItr()
				listeners[collider castTo int].onHit(collider, collidable)
				listeners[collidable castTo int].onHit(collider, collidable)
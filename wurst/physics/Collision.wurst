package Collision
import Rect
import LinkedList

public tuple rectangle(real minx, real miny, real maxx, real maxy)

public function rectangle.intersect(rectangle other) returns boolean
	return not (other.minx > this.maxx or other.maxx < this.minx or other.maxy > this.miny or other.miny < this.maxy)

public function rectangle.contains(vec2 point) returns boolean 
	return point.x > this.minx and point.x < this.maxx and point.y > this.miny and point.y < this.maxy

// There are 2 types of bodies
// Collidables provide collision for dynamic bodies, but do not collide themselves
// Colliders collide with collidables but not with themselves

public interface Collider
	function getPos() returns vec3
	function getVel() returns vec3

public interface Collidable
	function intersect(Collider collider) returns boolean
	function onCollision(Collider collider)

public class CollisionWorld
	rectangle worldBounds
	LinkedList<Collidable> collidables = new LinkedList<Collidable>()

	construct(rect re)
		worldBounds = rectangle(re.getMinX(), re.getMinY(), re.getMaxX(), re.getMaxY())

	function addCollidable(Collidable colliadable)
		collidables.add(colliadable)

	function update(Collider collider)
		// iterate through list of collision objects
		for collidable from collidables.staticItr()
			if collidable.intersect(collider)
				collidable.onCollision(collider)